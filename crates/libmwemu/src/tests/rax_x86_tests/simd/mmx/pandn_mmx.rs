//! Tests for PANDN instruction (MMX).
//!
//! PANDN - Logical AND NOT (MMX)
//!
//! Performs bitwise AND NOT operation: dest = (~dest) & src
//! The destination operand is inverted, then ANDed with the source.
//!
//! Opcode: 0F DF /r
//!
//! Flags affected: None
//!
//! Reference: /Users/int/dev/rax/docs/pandn.txt

use crate::*;

fn write_mm_via_mem(mem: u64, addr: u64, value: u64) {
    let mut emu = emu64();
    emu.maps.write_qword(addr, value);
}

// ============================================================================
// PANDN mm, mm/m64 (opcode 0F DF /r)
// ============================================================================

#[test]
fn test_pandn_mm_mm_basic() {
    let mut emu = emu64();
    let code = vec![
        0x0f, 0x6f, 0x04, 0x25, 0x00, 0x20, 0x00, 0x00, // MOVQ MM0, [0x2000]
        0x0f, 0x6f, 0x0c, 0x25, 0x08, 0x20, 0x00, 0x00, // MOVQ MM1, [0x2008]
        0x0f, 0xdf, 0xc1,                               // PANDN MM0, MM1
        0x0f, 0x7f, 0x04, 0x25, 0x10, 0x20, 0x00, 0x00, // MOVQ [0x2010], MM0
        0xf4,
    ];

    emu.load_code_bytes(&code);

    // (~0xF0F0F0F0F0F0F0F0) & 0xFF00FF00FF00FF00
    // = 0x0F0F0F0F0F0F0F0F & 0xFF00FF00FF00FF00
    // = 0x0F000F000F000F00
    emu.maps.write_qword(0x2000, 0xF0F0F0F0F0F0F0F0);
    emu.maps.write_qword(0x2008, 0xFF00FF00FF00FF00);

    emu.run(None).unwrap();

    let result = emu.maps.read_qword(0x2010).unwrap();
    assert_eq!(result, 0x0F000F000F000F00, "PANDN: basic operation");
}

#[test]
fn test_pandn_all_zeros() {
    let mut emu = emu64();
    let code = vec![
        0x0f, 0x6f, 0x04, 0x25, 0x00, 0x20, 0x00, 0x00,
        0x0f, 0x6f, 0x0c, 0x25, 0x08, 0x20, 0x00, 0x00,
        0x0f, 0xdf, 0xc1,
        0x0f, 0x7f, 0x04, 0x25, 0x10, 0x20, 0x00, 0x00,
        0xf4,
    ];

    emu.load_code_bytes(&code);

    // (~0x0000000000000000) & 0xFFFFFFFFFFFFFFFF = 0xFFFFFFFFFFFFFFFF
    emu.maps.write_qword(0x2000, 0x0000000000000000);
    emu.maps.write_qword(0x2008, 0xFFFFFFFFFFFFFFFF);

    emu.run(None).unwrap();

    let result = emu.maps.read_qword(0x2010).unwrap();
    assert_eq!(result, 0xFFFFFFFFFFFFFFFF, "PANDN: all zeros dest");
}

#[test]
fn test_pandn_all_ones() {
    let mut emu = emu64();
    let code = vec![
        0x0f, 0x6f, 0x04, 0x25, 0x00, 0x20, 0x00, 0x00,
        0x0f, 0x6f, 0x0c, 0x25, 0x08, 0x20, 0x00, 0x00,
        0x0f, 0xdf, 0xc1,
        0x0f, 0x7f, 0x04, 0x25, 0x10, 0x20, 0x00, 0x00,
        0xf4,
    ];

    emu.load_code_bytes(&code);

    // (~0xFFFFFFFFFFFFFFFF) & anything = 0x0000000000000000
    emu.maps.write_qword(0x2000, 0xFFFFFFFFFFFFFFFF);
    emu.maps.write_qword(0x2008, 0xAAAAAAAAAAAAAAAA);

    emu.run(None).unwrap();

    let result = emu.maps.read_qword(0x2010).unwrap();
    assert_eq!(result, 0x0000000000000000, "PANDN: all ones dest");
}

#[test]
fn test_pandn_identity() {
    let mut emu = emu64();
    let code = vec![
        0x0f, 0x6f, 0x04, 0x25, 0x00, 0x20, 0x00, 0x00,
        0x0f, 0x6f, 0x0c, 0x25, 0x08, 0x20, 0x00, 0x00,
        0x0f, 0xdf, 0xc1,
        0x0f, 0x7f, 0x04, 0x25, 0x10, 0x20, 0x00, 0x00,
        0xf4,
    ];

    emu.load_code_bytes(&code);

    // (~X) & X = 0
    emu.maps.write_qword(0x2000, 0x1234567890ABCDEF);
    emu.maps.write_qword(0x2008, 0x1234567890ABCDEF);

    emu.run(None).unwrap();

    let result = emu.maps.read_qword(0x2010).unwrap();
    assert_eq!(result, 0x0000000000000000, "PANDN: identity (X & ~X = 0)");
}

#[test]
fn test_pandn_complement() {
    let mut emu = emu64();
    let code = vec![
        0x0f, 0x6f, 0x04, 0x25, 0x00, 0x20, 0x00, 0x00,
        0x0f, 0x6f, 0x0c, 0x25, 0x08, 0x20, 0x00, 0x00,
        0x0f, 0xdf, 0xc1,
        0x0f, 0x7f, 0x04, 0x25, 0x10, 0x20, 0x00, 0x00,
        0xf4,
    ];

    emu.load_code_bytes(&code);

    // (~X) & ~X = ~X
    emu.maps.write_qword(0x2000, 0xAAAAAAAAAAAAAAAA);
    emu.maps.write_qword(0x2008, 0x5555555555555555);

    emu.run(None).unwrap();

    let result = emu.maps.read_qword(0x2010).unwrap();
    assert_eq!(result, 0x5555555555555555, "PANDN: complement pattern");
}

#[test]
fn test_pandn_mm_m64() {
    let mut emu = emu64();
    let code = vec![
        0x0f, 0x6f, 0x14, 0x25, 0x00, 0x20, 0x00, 0x00, // MOVQ MM2, [0x2000]
        0x0f, 0xdf, 0x14, 0x25, 0x08, 0x20, 0x00, 0x00, // PANDN MM2, [0x2008]
        0x0f, 0x7f, 0x14, 0x25, 0x10, 0x20, 0x00, 0x00, // MOVQ [0x2010], MM2
        0xf4,
    ];

    emu.load_code_bytes(&code);

    emu.maps.write_qword(0x2000, 0xFF00FF00FF00FF00);
    emu.maps.write_qword(0x2008, 0x0F0F0F0F0F0F0F0F);

    emu.run(None).unwrap();

    let result = emu.maps.read_qword(0x2010).unwrap();
    // ~0xFF00FF00FF00FF00 = 0x00FF00FF00FF00FF
    // 0x00FF00FF00FF00FF & 0x0F0F0F0F0F0F0F0F = 0x000F000F000F000F
    assert_eq!(result, 0x000F000F000F000F, "PANDN: memory operand");
}

#[test]
fn test_pandn_alternating_bits_1() {
    let mut emu = emu64();
    let code = vec![
        0x0f, 0x6f, 0x04, 0x25, 0x00, 0x20, 0x00, 0x00,
        0x0f, 0x6f, 0x0c, 0x25, 0x08, 0x20, 0x00, 0x00,
        0x0f, 0xdf, 0xc1,
        0x0f, 0x7f, 0x04, 0x25, 0x10, 0x20, 0x00, 0x00,
        0xf4,
    ];

    emu.load_code_bytes(&code);

    emu.maps.write_qword(0x2000, 0xAAAAAAAAAAAAAAAA);
    emu.maps.write_qword(0x2008, 0xFFFFFFFFFFFFFFFF);

    emu.run(None).unwrap();

    let result = emu.maps.read_qword(0x2010).unwrap();
    // ~0xAAAAAAAAAAAAAAAA = 0x5555555555555555
    // 0x5555555555555555 & 0xFFFFFFFFFFFFFFFF = 0x5555555555555555
    assert_eq!(result, 0x5555555555555555, "PANDN: alternating bits");
}

#[test]
fn test_pandn_alternating_bits_2() {
    let mut emu = emu64();
    let code = vec![
        0x0f, 0x6f, 0x04, 0x25, 0x00, 0x20, 0x00, 0x00,
        0x0f, 0x6f, 0x0c, 0x25, 0x08, 0x20, 0x00, 0x00,
        0x0f, 0xdf, 0xc1,
        0x0f, 0x7f, 0x04, 0x25, 0x10, 0x20, 0x00, 0x00,
        0xf4,
    ];

    emu.load_code_bytes(&code);

    emu.maps.write_qword(0x2000, 0x5555555555555555);
    emu.maps.write_qword(0x2008, 0xAAAAAAAAAAAAAAAA);

    emu.run(None).unwrap();

    let result = emu.maps.read_qword(0x2010).unwrap();
    // ~0x5555555555555555 = 0xAAAAAAAAAAAAAAAA
    // 0xAAAAAAAAAAAAAAAA & 0xAAAAAAAAAAAAAAAA = 0xAAAAAAAAAAAAAAAA
    assert_eq!(result, 0xAAAAAAAAAAAAAAAA, "PANDN: alternating bits reverse");
}

#[test]
fn test_pandn_byte_pattern() {
    let mut emu = emu64();
    let code = vec![
        0x0f, 0x6f, 0x04, 0x25, 0x00, 0x20, 0x00, 0x00,
        0x0f, 0x6f, 0x0c, 0x25, 0x08, 0x20, 0x00, 0x00,
        0x0f, 0xdf, 0xc1,
        0x0f, 0x7f, 0x04, 0x25, 0x10, 0x20, 0x00, 0x00,
        0xf4,
    ];

    emu.load_code_bytes(&code);

    emu.maps.write_qword(0x2000, 0x0123456789ABCDEF);
    emu.maps.write_qword(0x2008, 0xFEDCBA9876543210);

    emu.run(None).unwrap();

    let result = emu.maps.read_qword(0x2010).unwrap();
    // ~0x0123456789ABCDEF = 0xFEDCBA9876543210
    // 0xFEDCBA9876543210 & 0xFEDCBA9876543210 = 0xFEDCBA9876543210
    assert_eq!(result, 0xFEDCBA9876543210, "PANDN: byte pattern");
}

#[test]
fn test_pandn_high_bits() {
    let mut emu = emu64();
    let code = vec![
        0x0f, 0x6f, 0x04, 0x25, 0x00, 0x20, 0x00, 0x00,
        0x0f, 0x6f, 0x0c, 0x25, 0x08, 0x20, 0x00, 0x00,
        0x0f, 0xdf, 0xc1,
        0x0f, 0x7f, 0x04, 0x25, 0x10, 0x20, 0x00, 0x00,
        0xf4,
    ];

    emu.load_code_bytes(&code);

    emu.maps.write_qword(0x2000, 0xFFFFFFFF00000000);
    emu.maps.write_qword(0x2008, 0x00000000FFFFFFFF);

    emu.run(None).unwrap();

    let result = emu.maps.read_qword(0x2010).unwrap();
    // ~0xFFFFFFFF00000000 = 0x00000000FFFFFFFF
    // 0x00000000FFFFFFFF & 0x00000000FFFFFFFF = 0x00000000FFFFFFFF
    assert_eq!(result, 0x00000000FFFFFFFF, "PANDN: high bits");
}

#[test]
fn test_pandn_low_bits() {
    let mut emu = emu64();
    let code = vec![
        0x0f, 0x6f, 0x04, 0x25, 0x00, 0x20, 0x00, 0x00,
        0x0f, 0x6f, 0x0c, 0x25, 0x08, 0x20, 0x00, 0x00,
        0x0f, 0xdf, 0xc1,
        0x0f, 0x7f, 0x04, 0x25, 0x10, 0x20, 0x00, 0x00,
        0xf4,
    ];

    emu.load_code_bytes(&code);

    emu.maps.write_qword(0x2000, 0x00000000FFFFFFFF);
    emu.maps.write_qword(0x2008, 0xFFFFFFFF00000000);

    emu.run(None).unwrap();

    let result = emu.maps.read_qword(0x2010).unwrap();
    // ~0x00000000FFFFFFFF = 0xFFFFFFFF00000000
    // 0xFFFFFFFF00000000 & 0xFFFFFFFF00000000 = 0xFFFFFFFF00000000
    assert_eq!(result, 0xFFFFFFFF00000000, "PANDN: low bits");
}

#[test]
fn test_pandn_nibble_pattern() {
    let mut emu = emu64();
    let code = vec![
        0x0f, 0x6f, 0x04, 0x25, 0x00, 0x20, 0x00, 0x00,
        0x0f, 0x6f, 0x0c, 0x25, 0x08, 0x20, 0x00, 0x00,
        0x0f, 0xdf, 0xc1,
        0x0f, 0x7f, 0x04, 0x25, 0x10, 0x20, 0x00, 0x00,
        0xf4,
    ];

    emu.load_code_bytes(&code);

    emu.maps.write_qword(0x2000, 0xF0F0F0F0F0F0F0F0);
    emu.maps.write_qword(0x2008, 0x0F0F0F0F0F0F0F0F);

    emu.run(None).unwrap();

    let result = emu.maps.read_qword(0x2010).unwrap();
    // ~0xF0F0F0F0F0F0F0F0 = 0x0F0F0F0F0F0F0F0F
    // 0x0F0F0F0F0F0F0F0F & 0x0F0F0F0F0F0F0F0F = 0x0F0F0F0F0F0F0F0F
    assert_eq!(result, 0x0F0F0F0F0F0F0F0F, "PANDN: nibble pattern");
}

#[test]
fn test_pandn_sequential() {
    let mut emu = emu64();
    let code = vec![
        0x0f, 0x6f, 0x04, 0x25, 0x00, 0x20, 0x00, 0x00,
        0x0f, 0x6f, 0x0c, 0x25, 0x08, 0x20, 0x00, 0x00,
        0x0f, 0xdf, 0xc1,                               // PANDN MM0, MM1
        0x0f, 0xdf, 0xc1,                               // PANDN MM0, MM1 (again)
        0x0f, 0x7f, 0x04, 0x25, 0x10, 0x20, 0x00, 0x00,
        0xf4,
    ];

    emu.load_code_bytes(&code);

    emu.maps.write_qword(0x2000, 0xFFFF0000FFFF0000);
    emu.maps.write_qword(0x2008, 0x0000FFFF0000FFFF);

    emu.run(None).unwrap();

    let result = emu.maps.read_qword(0x2010).unwrap();
    assert_eq!(result, 0x0000000000000000, "PANDN: sequential operations");
}

#[test]
fn test_pandn_mm3_mm4() {
    let mut emu = emu64();
    let code = vec![
        0x0f, 0x6f, 0x1c, 0x25, 0x00, 0x20, 0x00, 0x00, // MOVQ MM3, [0x2000]
        0x0f, 0x6f, 0x24, 0x25, 0x08, 0x20, 0x00, 0x00, // MOVQ MM4, [0x2008]
        0x0f, 0xdf, 0xdc,                               // PANDN MM3, MM4
        0x0f, 0x7f, 0x1c, 0x25, 0x10, 0x20, 0x00, 0x00, // MOVQ [0x2010], MM3
        0xf4,
    ];

    emu.load_code_bytes(&code);

    emu.maps.write_qword(0x2000, 0x8080808080808080);
    emu.maps.write_qword(0x2008, 0x7F7F7F7F7F7F7F7F);

    emu.run(None).unwrap();

    let result = emu.maps.read_qword(0x2010).unwrap();
    // ~0x8080808080808080 = 0x7F7F7F7F7F7F7F7F
    // 0x7F7F7F7F7F7F7F7F & 0x7F7F7F7F7F7F7F7F = 0x7F7F7F7F7F7F7F7F
    assert_eq!(result, 0x7F7F7F7F7F7F7F7F, "PANDN: MM3 and MM4");
}

#[test]
fn test_pandn_single_bit_patterns() {
    let mut emu = emu64();
    let code = vec![
        0x0f, 0x6f, 0x04, 0x25, 0x00, 0x20, 0x00, 0x00,
        0x0f, 0x6f, 0x0c, 0x25, 0x08, 0x20, 0x00, 0x00,
        0x0f, 0xdf, 0xc1,
        0x0f, 0x7f, 0x04, 0x25, 0x10, 0x20, 0x00, 0x00,
        0xf4,
    ];

    emu.load_code_bytes(&code);

    emu.maps.write_qword(0x2000, 0x0000000000000001);
    emu.maps.write_qword(0x2008, 0xFFFFFFFFFFFFFFFE);

    emu.run(None).unwrap();

    let result = emu.maps.read_qword(0x2010).unwrap();
    // ~0x0000000000000001 = 0xFFFFFFFFFFFFFFFE
    // 0xFFFFFFFFFFFFFFFE & 0xFFFFFFFFFFFFFFFE = 0xFFFFFFFFFFFFFFFE
    assert_eq!(result, 0xFFFFFFFFFFFFFFFE, "PANDN: single bit patterns");
}

#[test]
fn test_pandn_msb_pattern() {
    let mut emu = emu64();
    let code = vec![
        0x0f, 0x6f, 0x04, 0x25, 0x00, 0x20, 0x00, 0x00,
        0x0f, 0x6f, 0x0c, 0x25, 0x08, 0x20, 0x00, 0x00,
        0x0f, 0xdf, 0xc1,
        0x0f, 0x7f, 0x04, 0x25, 0x10, 0x20, 0x00, 0x00,
        0xf4,
    ];

    emu.load_code_bytes(&code);

    emu.maps.write_qword(0x2000, 0x8000000000000000);
    emu.maps.write_qword(0x2008, 0x7FFFFFFFFFFFFFFF);

    emu.run(None).unwrap();

    let result = emu.maps.read_qword(0x2010).unwrap();
    // ~0x8000000000000000 = 0x7FFFFFFFFFFFFFFF
    // 0x7FFFFFFFFFFFFFFF & 0x7FFFFFFFFFFFFFFF = 0x7FFFFFFFFFFFFFFF
    assert_eq!(result, 0x7FFFFFFFFFFFFFFF, "PANDN: MSB pattern");
}

#[test]
fn test_pandn_byte_mask_1() {
    let mut emu = emu64();
    let code = vec![
        0x0f, 0x6f, 0x04, 0x25, 0x00, 0x20, 0x00, 0x00,
        0x0f, 0x6f, 0x0c, 0x25, 0x08, 0x20, 0x00, 0x00,
        0x0f, 0xdf, 0xc1,
        0x0f, 0x7f, 0x04, 0x25, 0x10, 0x20, 0x00, 0x00,
        0xf4,
    ];

    emu.load_code_bytes(&code);

    emu.maps.write_qword(0x2000, 0xFF00FF00FF00FF00);
    emu.maps.write_qword(0x2008, 0x0000FFFF0000FFFF);

    emu.run(None).unwrap();

    let result = emu.maps.read_qword(0x2010).unwrap();
    // ~0xFF00FF00FF00FF00 = 0x00FF00FF00FF00FF
    // 0x00FF00FF00FF00FF & 0x0000FFFF0000FFFF = 0x0000000F0000000F (wrong calc)
    // 0x00 & 0x00 = 0x00, 0xFF & 0x00 = 0x00, 0x00 & 0xFF = 0x00, 0xFF & 0xFF = 0xFF
    assert_eq!(result, 0x000000FF000000FF, "PANDN: byte mask 1");
}

#[test]
fn test_pandn_word_boundaries() {
    let mut emu = emu64();
    let code = vec![
        0x0f, 0x6f, 0x04, 0x25, 0x00, 0x20, 0x00, 0x00,
        0x0f, 0x6f, 0x0c, 0x25, 0x08, 0x20, 0x00, 0x00,
        0x0f, 0xdf, 0xc1,
        0x0f, 0x7f, 0x04, 0x25, 0x10, 0x20, 0x00, 0x00,
        0xf4,
    ];

    emu.load_code_bytes(&code);

    emu.maps.write_qword(0x2000, 0xFFFF0000FFFF0000);
    emu.maps.write_qword(0x2008, 0xFFFFFFFFFFFFFFFF);

    emu.run(None).unwrap();

    let result = emu.maps.read_qword(0x2010).unwrap();
    // ~0xFFFF0000FFFF0000 = 0x0000FFFF0000FFFF
    // 0x0000FFFF0000FFFF & 0xFFFFFFFFFFFFFFFF = 0x0000FFFF0000FFFF
    assert_eq!(result, 0x0000FFFF0000FFFF, "PANDN: word boundaries");
}

#[test]
fn test_pandn_dword_boundaries() {
    let mut emu = emu64();
    let code = vec![
        0x0f, 0x6f, 0x04, 0x25, 0x00, 0x20, 0x00, 0x00,
        0x0f, 0x6f, 0x0c, 0x25, 0x08, 0x20, 0x00, 0x00,
        0x0f, 0xdf, 0xc1,
        0x0f, 0x7f, 0x04, 0x25, 0x10, 0x20, 0x00, 0x00,
        0xf4,
    ];

    emu.load_code_bytes(&code);

    emu.maps.write_qword(0x2000, 0xFFFFFFFF00000000);
    emu.maps.write_qword(0x2008, 0x12345678FEDCBA98);

    emu.run(None).unwrap();

    let result = emu.maps.read_qword(0x2010).unwrap();
    // ~0xFFFFFFFF00000000 = 0x00000000FFFFFFFF
    // 0x00000000FFFFFFFF & 0x12345678FEDCBA98 = 0x00000000FEDCBA98
    assert_eq!(result, 0x00000000FEDCBA98, "PANDN: dword boundaries");
}

#[test]
fn test_pandn_sparse_bits() {
    let mut emu = emu64();
    let code = vec![
        0x0f, 0x6f, 0x04, 0x25, 0x00, 0x20, 0x00, 0x00,
        0x0f, 0x6f, 0x0c, 0x25, 0x08, 0x20, 0x00, 0x00,
        0x0f, 0xdf, 0xc1,
        0x0f, 0x7f, 0x04, 0x25, 0x10, 0x20, 0x00, 0x00,
        0xf4,
    ];

    emu.load_code_bytes(&code);

    emu.maps.write_qword(0x2000, 0x0101010101010101);
    emu.maps.write_qword(0x2008, 0xFEFEFEFEFEFEFEFE);

    emu.run(None).unwrap();

    let result = emu.maps.read_qword(0x2010).unwrap();
    // ~0x0101010101010101 = 0xFEFEFEFEFEFEFEFE
    // 0xFEFEFEFEFEFEFEFE & 0xFEFEFEFEFEFEFEFE = 0xFEFEFEFEFEFEFEFE
    assert_eq!(result, 0xFEFEFEFEFEFEFEFE, "PANDN: sparse bits");
}

#[test]
fn test_pandn_checkerboard_1() {
    let mut emu = emu64();
    let code = vec![
        0x0f, 0x6f, 0x04, 0x25, 0x00, 0x20, 0x00, 0x00,
        0x0f, 0x6f, 0x0c, 0x25, 0x08, 0x20, 0x00, 0x00,
        0x0f, 0xdf, 0xc1,
        0x0f, 0x7f, 0x04, 0x25, 0x10, 0x20, 0x00, 0x00,
        0xf4,
    ];

    emu.load_code_bytes(&code);

    emu.maps.write_qword(0x2000, 0xCCCCCCCCCCCCCCCC);
    emu.maps.write_qword(0x2008, 0x3333333333333333);

    emu.run(None).unwrap();

    let result = emu.maps.read_qword(0x2010).unwrap();
    // ~0xCCCCCCCCCCCCCCCC = 0x3333333333333333
    // 0x3333333333333333 & 0x3333333333333333 = 0x3333333333333333
    assert_eq!(result, 0x3333333333333333, "PANDN: checkerboard pattern");
}

#[test]
fn test_pandn_with_zeros_src() {
    let mut emu = emu64();
    let code = vec![
        0x0f, 0x6f, 0x04, 0x25, 0x00, 0x20, 0x00, 0x00,
        0x0f, 0x6f, 0x0c, 0x25, 0x08, 0x20, 0x00, 0x00,
        0x0f, 0xdf, 0xc1,
        0x0f, 0x7f, 0x04, 0x25, 0x10, 0x20, 0x00, 0x00,
        0xf4,
    ];

    emu.load_code_bytes(&code);

    // (~anything) & 0 = 0
    emu.maps.write_qword(0x2000, 0x123456789ABCDEF0);
    emu.maps.write_qword(0x2008, 0x0000000000000000);

    emu.run(None).unwrap();

    let result = emu.maps.read_qword(0x2010).unwrap();
    assert_eq!(result, 0x0000000000000000, "PANDN: source is zero");
}

#[test]
fn test_pandn_all_mm_registers() {
    let mut emu = emu64();
    let code = vec![
        0x0f, 0x6f, 0x2c, 0x25, 0x00, 0x20, 0x00, 0x00, // MOVQ MM5, [0x2000]
        0x0f, 0x6f, 0x34, 0x25, 0x08, 0x20, 0x00, 0x00, // MOVQ MM6, [0x2008]
        0x0f, 0xdf, 0xee,                               // PANDN MM5, MM6
        0x0f, 0x6f, 0x3c, 0x25, 0x10, 0x20, 0x00, 0x00, // MOVQ MM7, [0x2010]
        0x0f, 0xdf, 0xef,                               // PANDN MM5, MM7
        0x0f, 0x7f, 0x2c, 0x25, 0x18, 0x20, 0x00, 0x00, // MOVQ [0x2018], MM5
        0xf4,
    ];

    emu.load_code_bytes(&code);

    emu.maps.write_qword(0x2000, 0xF000000000000000);
    emu.maps.write_qword(0x2008, 0x0F00000000000000);
    emu.maps.write_qword(0x2010, 0x00F0000000000000);

    emu.run(None).unwrap();

    let result = emu.maps.read_qword(0x2018).unwrap();
    assert_eq!(result, 0x00F0000000000000, "PANDN: all MM registers");
}

#[test]
fn test_pandn_mask_isolation() {
    let mut emu = emu64();
    let code = vec![
        0x0f, 0x6f, 0x04, 0x25, 0x00, 0x20, 0x00, 0x00,
        0x0f, 0x6f, 0x0c, 0x25, 0x08, 0x20, 0x00, 0x00,
        0x0f, 0xdf, 0xc1,
        0x0f, 0x7f, 0x04, 0x25, 0x10, 0x20, 0x00, 0x00,
        0xf4,
    ];

    emu.load_code_bytes(&code);

    emu.maps.write_qword(0x2000, 0xF0F0F0F0F0F0F0F0);
    emu.maps.write_qword(0x2008, 0x123456789ABCDEF0);

    emu.run(None).unwrap();

    let result = emu.maps.read_qword(0x2010).unwrap();
    // ~0xF0F0F0F0F0F0F0F0 = 0x0F0F0F0F0F0F0F0F
    // 0x0F0F0F0F0F0F0F0F & 0x123456789ABCDEF0 = 0x020406080A0C0E00
    assert_eq!(result, 0x020406080A0C0E00, "PANDN: mask isolation");
}

#[test]
fn test_pandn_bit_clearing() {
    let mut emu = emu64();
    let code = vec![
        0x0f, 0x6f, 0x04, 0x25, 0x00, 0x20, 0x00, 0x00,
        0x0f, 0x6f, 0x0c, 0x25, 0x08, 0x20, 0x00, 0x00,
        0x0f, 0xdf, 0xc1,
        0x0f, 0x7f, 0x04, 0x25, 0x10, 0x20, 0x00, 0x00,
        0xf4,
    ];

    emu.load_code_bytes(&code);

    emu.maps.write_qword(0x2000, 0x00000000000000FF); // Clear all but low byte
    emu.maps.write_qword(0x2008, 0xFFFFFFFFFFFFFFFF);

    emu.run(None).unwrap();

    let result = emu.maps.read_qword(0x2010).unwrap();
    // ~0x00000000000000FF = 0xFFFFFFFFFFFFFF00
    // 0xFFFFFFFFFFFFFF00 & 0xFFFFFFFFFFFFFFFF = 0xFFFFFFFFFFFFFF00
    assert_eq!(result, 0xFFFFFFFFFFFFFF00, "PANDN: bit clearing");
}

#[test]
fn test_pandn_random_pattern_1() {
    let mut emu = emu64();
    let code = vec![
        0x0f, 0x6f, 0x04, 0x25, 0x00, 0x20, 0x00, 0x00,
        0x0f, 0x6f, 0x0c, 0x25, 0x08, 0x20, 0x00, 0x00,
        0x0f, 0xdf, 0xc1,
        0x0f, 0x7f, 0x04, 0x25, 0x10, 0x20, 0x00, 0x00,
        0xf4,
    ];

    emu.load_code_bytes(&code);

    emu.maps.write_qword(0x2000, 0xDEADBEEFCAFEBABE);
    emu.maps.write_qword(0x2008, 0x2152411035014541);

    emu.run(None).unwrap();

    let result = emu.maps.read_qword(0x2010).unwrap();
    // ~0xDEADBEEFCAFEBABE = 0x2152411035014541
    // 0x2152411035014541 & 0x2152411035014541 = 0x2152411035014541
    assert_eq!(result, 0x2152411035014541, "PANDN: random pattern 1");
}

#[test]
fn test_pandn_random_pattern_2() {
    let mut emu = emu64();
    let code = vec![
        0x0f, 0x6f, 0x04, 0x25, 0x00, 0x20, 0x00, 0x00,
        0x0f, 0x6f, 0x0c, 0x25, 0x08, 0x20, 0x00, 0x00,
        0x0f, 0xdf, 0xc1,
        0x0f, 0x7f, 0x04, 0x25, 0x10, 0x20, 0x00, 0x00,
        0xf4,
    ];

    emu.load_code_bytes(&code);

    emu.maps.write_qword(0x2000, 0x8421084210842108);
    emu.maps.write_qword(0x2008, 0x7BDEF7BDEF7BDEF7);

    emu.run(None).unwrap();

    let result = emu.maps.read_qword(0x2010).unwrap();
    // ~0x8421084210842108 = 0x7BDEF7BDEF7BDEF7
    // 0x7BDEF7BDEF7BDEF7 & 0x7BDEF7BDEF7BDEF7 = 0x7BDEF7BDEF7BDEF7
    assert_eq!(result, 0x7BDEF7BDEF7BDEF7, "PANDN: random pattern 2");
}

#[test]
fn test_pandn_power_of_two() {
    let mut emu = emu64();
    let code = vec![
        0x0f, 0x6f, 0x04, 0x25, 0x00, 0x20, 0x00, 0x00,
        0x0f, 0x6f, 0x0c, 0x25, 0x08, 0x20, 0x00, 0x00,
        0x0f, 0xdf, 0xc1,
        0x0f, 0x7f, 0x04, 0x25, 0x10, 0x20, 0x00, 0x00,
        0xf4,
    ];

    emu.load_code_bytes(&code);

    emu.maps.write_qword(0x2000, 0x0000000000000100); // Bit 8
    emu.maps.write_qword(0x2008, 0xFFFFFFFFFFFFFEFF);

    emu.run(None).unwrap();

    let result = emu.maps.read_qword(0x2010).unwrap();
    // ~0x0000000000000100 = 0xFFFFFFFFFFFFFEFF
    // 0xFFFFFFFFFFFFFEFF & 0xFFFFFFFFFFFFFEFF = 0xFFFFFFFFFFFFFEFF
    assert_eq!(result, 0xFFFFFFFFFFFFFEFF, "PANDN: power of two");
}

#[test]
fn test_pandn_complement_validation() {
    let mut emu = emu64();
    let code = vec![
        0x0f, 0x6f, 0x04, 0x25, 0x00, 0x20, 0x00, 0x00,
        0x0f, 0x6f, 0x0c, 0x25, 0x08, 0x20, 0x00, 0x00,
        0x0f, 0xdf, 0xc1,
        0x0f, 0x7f, 0x04, 0x25, 0x10, 0x20, 0x00, 0x00,
        0xf4,
    ];

    let test_values = vec![
        (0x0000000000000000u64, 0xFFFFFFFFFFFFFFFFu64),
        (0xFFFFFFFFFFFFFFFFu64, 0x0000000000000000u64),
        (0xAAAAAAAAAAAAAAAAu64, 0x5555555555555555u64),
        (0x5555555555555555u64, 0xAAAAAAAAAAAAAAAAu64),
        (0xF0F0F0F0F0F0F0F0u64, 0x0F0F0F0F0F0F0F0Fu64),
    ];

    for (dest, src) in test_values {
        emu.load_code_bytes(&code);
        emu.maps.write_qword(0x2000, dest);
        emu.maps.write_qword(0x2008, src);
    emu.run(None).unwrap();
        let result = emu.maps.read_qword(0x2010).unwrap();
        assert_eq!(result, src, "PANDN: complement should yield source");
    }
}

#[test]
fn test_pandn_associativity() {
    let mut emu = emu64();
    let code = vec![
        0x0f, 0x6f, 0x04, 0x25, 0x00, 0x20, 0x00, 0x00,
        0x0f, 0x6f, 0x0c, 0x25, 0x08, 0x20, 0x00, 0x00,
        0x0f, 0xdf, 0xc1,                               // MM0 = ~MM0 & MM1
        0x0f, 0x6f, 0x14, 0x25, 0x10, 0x20, 0x00, 0x00,
        0x0f, 0xdf, 0xc2,                               // MM0 = ~MM0 & MM2
        0x0f, 0x7f, 0x04, 0x25, 0x18, 0x20, 0x00, 0x00,
        0xf4,
    ];

    emu.load_code_bytes(&code);

    emu.maps.write_qword(0x2000, 0xFFFFFFFF00000000);
    emu.maps.write_qword(0x2008, 0xFFFF0000FFFF0000);
    emu.maps.write_qword(0x2010, 0xFF00FF00FF00FF00);

    emu.run(None).unwrap();

    let result = emu.maps.read_qword(0x2018).unwrap();
    assert_eq!(result, 0xFF00FF000000FF00, "PANDN: chained operations");
}
