use crate::*;

// ANDPS/ANDPD - Bitwise Logical AND of Packed Floating-Point Values
//
// Performs bitwise AND of packed single/double precision floating-point values.
// These are bitwise operations, not arithmetic operations.
//
// Opcodes:
// NP 0F 54 /r      - ANDPS xmm1, xmm2/m128
// 66 0F 54 /r      - ANDPD xmm1, xmm2/m128

const ALIGNED_ADDR: u64 = 0x3000;
const ALIGNED_ADDR2: u64 = 0x3100;

// Helper functions
fn make_4floats(f0: f32, f1: f32, f2: f32, f3: f32) -> Vec<u8> {
    let mut data = Vec::new();
    data.extend_from_slice(&f0.to_le_bytes());
    data.extend_from_slice(&f1.to_le_bytes());
    data.extend_from_slice(&f2.to_le_bytes());
    data.extend_from_slice(&f3.to_le_bytes());
    data
}

fn make_2doubles(f0: f64, f1: f64) -> Vec<u8> {
    let mut data = Vec::new();
    data.extend_from_slice(&f0.to_le_bytes());
    data.extend_from_slice(&f1.to_le_bytes());
    data
}

// ============================================================================
// ANDPS Tests - Single Precision
// ============================================================================

#[test]
fn test_andps_all_ones_all_ones() {
    let mut emu = emu64();
    let code = [0x48, 0xb8]; // MOV RAX, imm64
    let mut full_code = code.to_vec();
    full_code.extend_from_slice(&ALIGNED_ADDR.to_le_bytes());
    full_code.extend_from_slice(&[0x48, 0xbb]); // MOV RBX, imm64
    full_code.extend_from_slice(&ALIGNED_ADDR2.to_le_bytes());
    full_code.extend_from_slice(&[
        0x0f, 0x28, 0x00, // MOVAPS XMM0, [RAX]
        0x0f, 0x28, 0x0b, // MOVAPS XMM1, [RBX]
        0x0f, 0x54, 0xc1, // ANDPS XMM0, XMM1
        0xf4, // HLT
    ]);

    emu.load_code_bytes(&full_code);
    emu.maps.write_bytes_slice(ALIGNED_ADDR, &[0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF]);
    emu.maps.write_bytes_slice(ALIGNED_ADDR2, &[0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF]);
    emu.run(None).unwrap();
}

#[test]
fn test_andps_all_ones_all_zeros() {
    let mut emu = emu64();
    let code = [0x48, 0xb8]; 
    let mut full_code = code.to_vec();
    full_code.extend_from_slice(&ALIGNED_ADDR.to_le_bytes());
    full_code.extend_from_slice(&[0x48, 0xbb]);
    full_code.extend_from_slice(&ALIGNED_ADDR2.to_le_bytes());
    full_code.extend_from_slice(&[
        0x0f, 0x28, 0x00, 0x0f, 0x28, 0x0b,
        0x0f, 0x54, 0xc1, 0xf4,
    ]);

    emu.load_code_bytes(&full_code);
    emu.maps.write_bytes_slice(ALIGNED_ADDR, &[0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF]);
    emu.maps.write_bytes_slice(ALIGNED_ADDR2, &[0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]);
    emu.run(None).unwrap();
}

#[test]
fn test_andps_alternating_bits() {
    let mut emu = emu64();
    let code = [0x48, 0xb8];
    let mut full_code = code.to_vec();
    full_code.extend_from_slice(&ALIGNED_ADDR.to_le_bytes());
    full_code.extend_from_slice(&[0x48, 0xbb]);
    full_code.extend_from_slice(&ALIGNED_ADDR2.to_le_bytes());
    full_code.extend_from_slice(&[
        0x0f, 0x28, 0x00, 0x0f, 0x28, 0x0b,
        0x0f, 0x54, 0xc1, 0xf4,
    ]);

    emu.load_code_bytes(&full_code);
    emu.maps.write_bytes_slice(ALIGNED_ADDR, &[0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA]);
    emu.maps.write_bytes_slice(ALIGNED_ADDR2, &[0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55]);
    emu.run(None).unwrap();
}

#[test]
fn test_andps_sign_bit_mask() {
    let mut emu = emu64();
    let code = [0x48, 0xb8];
    let mut full_code = code.to_vec();
    full_code.extend_from_slice(&ALIGNED_ADDR.to_le_bytes());
    full_code.extend_from_slice(&[0x48, 0xbb]);
    full_code.extend_from_slice(&ALIGNED_ADDR2.to_le_bytes());
    full_code.extend_from_slice(&[
        0x0f, 0x28, 0x00, 0x0f, 0x28, 0x0b,
        0x0f, 0x54, 0xc1, 0xf4,
    ]);

    emu.load_code_bytes(&full_code);
    emu.maps.write_bytes_slice(ALIGNED_ADDR, &make_4floats(-1.0, -2.0, -3.0, -4.0));
    emu.maps.write_bytes_slice(ALIGNED_ADDR2, &[0x80, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00]);
    emu.run(None).unwrap();
}

#[test]
fn test_andps_clear_sign_bit() {
    let mut emu = emu64();
    let code = [0x48, 0xb8];
    let mut full_code = code.to_vec();
    full_code.extend_from_slice(&ALIGNED_ADDR.to_le_bytes());
    full_code.extend_from_slice(&[0x48, 0xbb]);
    full_code.extend_from_slice(&ALIGNED_ADDR2.to_le_bytes());
    full_code.extend_from_slice(&[
        0x0f, 0x28, 0x00, 0x0f, 0x28, 0x0b,
        0x0f, 0x54, 0xc1, 0xf4,
    ]);

    emu.load_code_bytes(&full_code);
    emu.maps.write_bytes_slice(ALIGNED_ADDR, &make_4floats(-1.0, -2.0, -3.0, -4.0));
    emu.maps.write_bytes_slice(ALIGNED_ADDR2, &[0x7F, 0xFF, 0xFF, 0xFF, 0x7F, 0xFF, 0xFF, 0xFF, 0x7F, 0xFF, 0xFF, 0xFF, 0x7F, 0xFF, 0xFF, 0xFF]);
    emu.run(None).unwrap();
}

#[test]
fn test_andps_reg_reg_xmm2_xmm3() {
    let mut emu = emu64();
    let code = [0x48, 0xb8];
    let mut full_code = code.to_vec();
    full_code.extend_from_slice(&ALIGNED_ADDR.to_le_bytes());
    full_code.extend_from_slice(&[0x48, 0xbb]);
    full_code.extend_from_slice(&ALIGNED_ADDR2.to_le_bytes());
    full_code.extend_from_slice(&[
        0x0f, 0x28, 0x10, // MOVAPS XMM2, [RAX]
        0x0f, 0x28, 0x1b, // MOVAPS XMM3, [RBX]
        0x0f, 0x54, 0xd3, // ANDPS XMM2, XMM3
        0xf4,
    ]);

    emu.load_code_bytes(&full_code);
    emu.maps.write_bytes_slice(ALIGNED_ADDR, &[0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF]);
    emu.maps.write_bytes_slice(ALIGNED_ADDR2, &[0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA]);
    emu.run(None).unwrap();
}

#[test]
fn test_andps_xmm7_xmm6() {
    let mut emu = emu64();
    let code = [0x48, 0xb8];
    let mut full_code = code.to_vec();
    full_code.extend_from_slice(&ALIGNED_ADDR.to_le_bytes());
    full_code.extend_from_slice(&[0x48, 0xbb]);
    full_code.extend_from_slice(&ALIGNED_ADDR2.to_le_bytes());
    full_code.extend_from_slice(&[
        0x0f, 0x28, 0x38, 0x0f, 0x28, 0x33,
        0x0f, 0x54, 0xfe, 0xf4,
    ]);

    emu.load_code_bytes(&full_code);
    emu.maps.write_bytes_slice(ALIGNED_ADDR, &[0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0]);
    emu.maps.write_bytes_slice(ALIGNED_ADDR2, &[0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F]);
    emu.run(None).unwrap();
}

#[test]
fn test_andps_xmm15_xmm8() {
    let mut emu = emu64();
    let code = [0x48, 0xb8];
    let mut full_code = code.to_vec();
    full_code.extend_from_slice(&ALIGNED_ADDR.to_le_bytes());
    full_code.extend_from_slice(&[0x48, 0xbb]);
    full_code.extend_from_slice(&ALIGNED_ADDR2.to_le_bytes());
    full_code.extend_from_slice(&[
        0x44, 0x0f, 0x28, 0x38, // MOVAPS XMM15, [RAX]
        0x44, 0x0f, 0x28, 0x03, // MOVAPS XMM8, [RBX]
        0x45, 0x0f, 0x54, 0xf8, // ANDPS XMM15, XMM8
        0xf4,
    ]);

    emu.load_code_bytes(&full_code);
    emu.maps.write_bytes_slice(ALIGNED_ADDR, &[0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF]);
    emu.maps.write_bytes_slice(ALIGNED_ADDR2, &[0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33]);
    emu.run(None).unwrap();
}

#[test]
fn test_andps_memory_operand() {
    let mut emu = emu64();
    let code = [0x48, 0xb8];
    let mut full_code = code.to_vec();
    full_code.extend_from_slice(&ALIGNED_ADDR.to_le_bytes());
    full_code.extend_from_slice(&[0x48, 0xbb]);
    full_code.extend_from_slice(&ALIGNED_ADDR2.to_le_bytes());
    full_code.extend_from_slice(&[
        0x0f, 0x28, 0x00, // MOVAPS XMM0, [RAX]
        0x0f, 0x54, 0x03, // ANDPS XMM0, [RBX]
        0xf4,
    ]);

    emu.load_code_bytes(&full_code);
    emu.maps.write_bytes_slice(ALIGNED_ADDR, &[0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC]);
    emu.maps.write_bytes_slice(ALIGNED_ADDR2, &[0x3C, 0x3C, 0x3C, 0x3C, 0x3C, 0x3C, 0x3C, 0x3C, 0x3C, 0x3C, 0x3C, 0x3C, 0x3C, 0x3C, 0x3C, 0x3C]);
    emu.run(None).unwrap();
}

#[test]
fn test_andps_sequential_patterns() {
    let mut emu = emu64();
    let code = [0x48, 0xb8];
    let mut full_code = code.to_vec();
    full_code.extend_from_slice(&ALIGNED_ADDR.to_le_bytes());
    full_code.extend_from_slice(&[0x48, 0xbb]);
    full_code.extend_from_slice(&ALIGNED_ADDR2.to_le_bytes());
    full_code.extend_from_slice(&[
        0x0f, 0x28, 0x00, 0x0f, 0x28, 0x0b,
        0x0f, 0x54, 0xc1, 0xf4,
    ]);

    emu.load_code_bytes(&full_code);
    emu.maps.write_bytes_slice(ALIGNED_ADDR, &[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]);
    emu.maps.write_bytes_slice(ALIGNED_ADDR2, &[15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0]);
    emu.run(None).unwrap();
}

// ============================================================================
// ANDPD Tests - Double Precision
// ============================================================================

#[test]
fn test_andpd_all_ones_all_ones() {
    let mut emu = emu64();
    let code = [0x48, 0xb8];
    let mut full_code = code.to_vec();
    full_code.extend_from_slice(&ALIGNED_ADDR.to_le_bytes());
    full_code.extend_from_slice(&[0x48, 0xbb]);
    full_code.extend_from_slice(&ALIGNED_ADDR2.to_le_bytes());
    full_code.extend_from_slice(&[
        0x66, 0x0f, 0x28, 0x00, // MOVAPD XMM0, [RAX]
        0x66, 0x0f, 0x28, 0x0b, // MOVAPD XMM1, [RBX]
        0x66, 0x0f, 0x54, 0xc1, // ANDPD XMM0, XMM1
        0xf4,
    ]);

    emu.load_code_bytes(&full_code);
    emu.maps.write_bytes_slice(ALIGNED_ADDR, &[0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF]);
    emu.maps.write_bytes_slice(ALIGNED_ADDR2, &[0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF]);
    emu.run(None).unwrap();
}

#[test]
fn test_andpd_all_ones_all_zeros() {
    let mut emu = emu64();
    let code = [0x48, 0xb8];
    let mut full_code = code.to_vec();
    full_code.extend_from_slice(&ALIGNED_ADDR.to_le_bytes());
    full_code.extend_from_slice(&[0x48, 0xbb]);
    full_code.extend_from_slice(&ALIGNED_ADDR2.to_le_bytes());
    full_code.extend_from_slice(&[
        0x66, 0x0f, 0x28, 0x00, 0x66, 0x0f, 0x28, 0x0b,
        0x66, 0x0f, 0x54, 0xc1, 0xf4,
    ]);

    emu.load_code_bytes(&full_code);
    emu.maps.write_bytes_slice(ALIGNED_ADDR, &[0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF]);
    emu.maps.write_bytes_slice(ALIGNED_ADDR2, &[0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]);
    emu.run(None).unwrap();
}

#[test]
fn test_andpd_alternating_bits() {
    let mut emu = emu64();
    let code = [0x48, 0xb8];
    let mut full_code = code.to_vec();
    full_code.extend_from_slice(&ALIGNED_ADDR.to_le_bytes());
    full_code.extend_from_slice(&[0x48, 0xbb]);
    full_code.extend_from_slice(&ALIGNED_ADDR2.to_le_bytes());
    full_code.extend_from_slice(&[
        0x66, 0x0f, 0x28, 0x00, 0x66, 0x0f, 0x28, 0x0b,
        0x66, 0x0f, 0x54, 0xc1, 0xf4,
    ]);

    emu.load_code_bytes(&full_code);
    emu.maps.write_bytes_slice(ALIGNED_ADDR, &[0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA]);
    emu.maps.write_bytes_slice(ALIGNED_ADDR2, &[0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55]);
    emu.run(None).unwrap();
}

#[test]
fn test_andpd_sign_bit_mask() {
    let mut emu = emu64();
    let code = [0x48, 0xb8];
    let mut full_code = code.to_vec();
    full_code.extend_from_slice(&ALIGNED_ADDR.to_le_bytes());
    full_code.extend_from_slice(&[0x48, 0xbb]);
    full_code.extend_from_slice(&ALIGNED_ADDR2.to_le_bytes());
    full_code.extend_from_slice(&[
        0x66, 0x0f, 0x28, 0x00, 0x66, 0x0f, 0x28, 0x0b,
        0x66, 0x0f, 0x54, 0xc1, 0xf4,
    ]);

    emu.load_code_bytes(&full_code);
    emu.maps.write_bytes_slice(ALIGNED_ADDR, &make_2doubles(-1.0, -2.0));
    emu.maps.write_bytes_slice(ALIGNED_ADDR2, &[0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]);
    emu.run(None).unwrap();
}

#[test]
fn test_andpd_clear_sign_bit() {
    let mut emu = emu64();
    let code = [0x48, 0xb8];
    let mut full_code = code.to_vec();
    full_code.extend_from_slice(&ALIGNED_ADDR.to_le_bytes());
    full_code.extend_from_slice(&[0x48, 0xbb]);
    full_code.extend_from_slice(&ALIGNED_ADDR2.to_le_bytes());
    full_code.extend_from_slice(&[
        0x66, 0x0f, 0x28, 0x00, 0x66, 0x0f, 0x28, 0x0b,
        0x66, 0x0f, 0x54, 0xc1, 0xf4,
    ]);

    emu.load_code_bytes(&full_code);
    emu.maps.write_bytes_slice(ALIGNED_ADDR, &make_2doubles(-1.0, -2.0));
    emu.maps.write_bytes_slice(ALIGNED_ADDR2, &[0x7F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x7F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF]);
    emu.run(None).unwrap();
}

#[test]
fn test_andpd_reg_reg_xmm2_xmm3() {
    let mut emu = emu64();
    let code = [0x48, 0xb8];
    let mut full_code = code.to_vec();
    full_code.extend_from_slice(&ALIGNED_ADDR.to_le_bytes());
    full_code.extend_from_slice(&[0x48, 0xbb]);
    full_code.extend_from_slice(&ALIGNED_ADDR2.to_le_bytes());
    full_code.extend_from_slice(&[
        0x66, 0x0f, 0x28, 0x10, // MOVAPD XMM2, [RAX]
        0x66, 0x0f, 0x28, 0x1b, // MOVAPD XMM3, [RBX]
        0x66, 0x0f, 0x54, 0xd3, // ANDPD XMM2, XMM3
        0xf4,
    ]);

    emu.load_code_bytes(&full_code);
    emu.maps.write_bytes_slice(ALIGNED_ADDR, &[0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF]);
    emu.maps.write_bytes_slice(ALIGNED_ADDR2, &[0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA]);
    emu.run(None).unwrap();
}

#[test]
fn test_andpd_xmm7_xmm6() {
    let mut emu = emu64();
    let code = [0x48, 0xb8];
    let mut full_code = code.to_vec();
    full_code.extend_from_slice(&ALIGNED_ADDR.to_le_bytes());
    full_code.extend_from_slice(&[0x48, 0xbb]);
    full_code.extend_from_slice(&ALIGNED_ADDR2.to_le_bytes());
    full_code.extend_from_slice(&[
        0x66, 0x0f, 0x28, 0x38, 0x66, 0x0f, 0x28, 0x33,
        0x66, 0x0f, 0x54, 0xfe, 0xf4,
    ]);

    emu.load_code_bytes(&full_code);
    emu.maps.write_bytes_slice(ALIGNED_ADDR, &[0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0]);
    emu.maps.write_bytes_slice(ALIGNED_ADDR2, &[0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F]);
    emu.run(None).unwrap();
}

#[test]
fn test_andpd_xmm15_xmm8() {
    let mut emu = emu64();
    let code = [0x48, 0xb8];
    let mut full_code = code.to_vec();
    full_code.extend_from_slice(&ALIGNED_ADDR.to_le_bytes());
    full_code.extend_from_slice(&[0x48, 0xbb]);
    full_code.extend_from_slice(&ALIGNED_ADDR2.to_le_bytes());
    full_code.extend_from_slice(&[
        0x66, 0x44, 0x0f, 0x28, 0x38, // MOVAPD XMM15, [RAX]
        0x66, 0x44, 0x0f, 0x28, 0x03, // MOVAPD XMM8, [RBX]
        0x66, 0x45, 0x0f, 0x54, 0xf8, // ANDPD XMM15, XMM8
        0xf4,
    ]);

    emu.load_code_bytes(&full_code);
    emu.maps.write_bytes_slice(ALIGNED_ADDR, &[0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF]);
    emu.maps.write_bytes_slice(ALIGNED_ADDR2, &[0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33]);
    emu.run(None).unwrap();
}

#[test]
fn test_andpd_memory_operand() {
    let mut emu = emu64();
    let code = [0x48, 0xb8];
    let mut full_code = code.to_vec();
    full_code.extend_from_slice(&ALIGNED_ADDR.to_le_bytes());
    full_code.extend_from_slice(&[0x48, 0xbb]);
    full_code.extend_from_slice(&ALIGNED_ADDR2.to_le_bytes());
    full_code.extend_from_slice(&[
        0x66, 0x0f, 0x28, 0x00, // MOVAPD XMM0, [RAX]
        0x66, 0x0f, 0x54, 0x03, // ANDPD XMM0, [RBX]
        0xf4,
    ]);

    emu.load_code_bytes(&full_code);
    emu.maps.write_bytes_slice(ALIGNED_ADDR, &[0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC]);
    emu.maps.write_bytes_slice(ALIGNED_ADDR2, &[0x3C, 0x3C, 0x3C, 0x3C, 0x3C, 0x3C, 0x3C, 0x3C, 0x3C, 0x3C, 0x3C, 0x3C, 0x3C, 0x3C, 0x3C, 0x3C]);
    emu.run(None).unwrap();
}

#[test]
fn test_andpd_sequential_patterns() {
    let mut emu = emu64();
    let code = [0x48, 0xb8];
    let mut full_code = code.to_vec();
    full_code.extend_from_slice(&ALIGNED_ADDR.to_le_bytes());
    full_code.extend_from_slice(&[0x48, 0xbb]);
    full_code.extend_from_slice(&ALIGNED_ADDR2.to_le_bytes());
    full_code.extend_from_slice(&[
        0x66, 0x0f, 0x28, 0x00, 0x66, 0x0f, 0x28, 0x0b,
        0x66, 0x0f, 0x54, 0xc1, 0xf4,
    ]);

    emu.load_code_bytes(&full_code);
    emu.maps.write_bytes_slice(ALIGNED_ADDR, &[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]);
    emu.maps.write_bytes_slice(ALIGNED_ADDR2, &[15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0]);
    emu.run(None).unwrap();
}

// ============================================================================
// Mixed ANDPS/ANDPD Tests
// ============================================================================

#[test]
fn test_andps_with_infinity() {
    let mut emu = emu64();
    let code = [0x48, 0xb8];
    let mut full_code = code.to_vec();
    full_code.extend_from_slice(&ALIGNED_ADDR.to_le_bytes());
    full_code.extend_from_slice(&[0x48, 0xbb]);
    full_code.extend_from_slice(&ALIGNED_ADDR2.to_le_bytes());
    full_code.extend_from_slice(&[
        0x0f, 0x28, 0x00, 0x0f, 0x28, 0x0b,
        0x0f, 0x54, 0xc1, 0xf4,
    ]);

    emu.load_code_bytes(&full_code);
    emu.maps.write_bytes_slice(ALIGNED_ADDR, &make_4floats(f32::INFINITY, f32::NEG_INFINITY, 1.0, 2.0));
    emu.maps.write_bytes_slice(ALIGNED_ADDR2, &[0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF]);
    emu.run(None).unwrap();
}

#[test]
fn test_andpd_with_infinity() {
    let mut emu = emu64();
    let code = [0x48, 0xb8];
    let mut full_code = code.to_vec();
    full_code.extend_from_slice(&ALIGNED_ADDR.to_le_bytes());
    full_code.extend_from_slice(&[0x48, 0xbb]);
    full_code.extend_from_slice(&ALIGNED_ADDR2.to_le_bytes());
    full_code.extend_from_slice(&[
        0x66, 0x0f, 0x28, 0x00, 0x66, 0x0f, 0x28, 0x0b,
        0x66, 0x0f, 0x54, 0xc1, 0xf4,
    ]);

    emu.load_code_bytes(&full_code);
    emu.maps.write_bytes_slice(ALIGNED_ADDR, &make_2doubles(f64::INFINITY, f64::NEG_INFINITY));
    emu.maps.write_bytes_slice(ALIGNED_ADDR2, &[0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF]);
    emu.run(None).unwrap();
}

#[test]
fn test_andps_with_nan() {
    let mut emu = emu64();
    let code = [0x48, 0xb8];
    let mut full_code = code.to_vec();
    full_code.extend_from_slice(&ALIGNED_ADDR.to_le_bytes());
    full_code.extend_from_slice(&[0x48, 0xbb]);
    full_code.extend_from_slice(&ALIGNED_ADDR2.to_le_bytes());
    full_code.extend_from_slice(&[
        0x0f, 0x28, 0x00, 0x0f, 0x28, 0x0b,
        0x0f, 0x54, 0xc1, 0xf4,
    ]);

    emu.load_code_bytes(&full_code);
    emu.maps.write_bytes_slice(ALIGNED_ADDR, &make_4floats(f32::NAN, 1.0, 2.0, 3.0));
    emu.maps.write_bytes_slice(ALIGNED_ADDR2, &[0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF]);
    emu.run(None).unwrap();
}

#[test]
fn test_andpd_with_nan() {
    let mut emu = emu64();
    let code = [0x48, 0xb8];
    let mut full_code = code.to_vec();
    full_code.extend_from_slice(&ALIGNED_ADDR.to_le_bytes());
    full_code.extend_from_slice(&[0x48, 0xbb]);
    full_code.extend_from_slice(&ALIGNED_ADDR2.to_le_bytes());
    full_code.extend_from_slice(&[
        0x66, 0x0f, 0x28, 0x00, 0x66, 0x0f, 0x28, 0x0b,
        0x66, 0x0f, 0x54, 0xc1, 0xf4,
    ]);

    emu.load_code_bytes(&full_code);
    emu.maps.write_bytes_slice(ALIGNED_ADDR, &make_2doubles(f64::NAN, 1.0));
    emu.maps.write_bytes_slice(ALIGNED_ADDR2, &[0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF]);
    emu.run(None).unwrap();
}

// Additional 20 tests for comprehensive coverage
#[test] fn test_andps_nibble_pattern_1() {
    let mut emu = emu64();
 let code = [0x48, 0xb8]; let mut full_code = code.to_vec();
 full_code.extend_from_slice(&ALIGNED_ADDR.to_le_bytes());
 full_code.extend_from_slice(&[0x48, 0xbb]);
 full_code.extend_from_slice(&ALIGNED_ADDR2.to_le_bytes());
 full_code.extend_from_slice(&[0x0f, 0x28, 0x00, 0x0f, 0x28, 0x0b, 0x0f, 0x54, 0xc1, 0xf4]);
 emu.load_code_bytes(&full_code);
 emu.maps.write_bytes_slice(ALIGNED_ADDR, &[0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F]);
 emu.maps.write_bytes_slice(ALIGNED_ADDR2, &[0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0]);
    emu.run(None).unwrap();
}
#[test] fn test_andpd_nibble_pattern_1() {
    let mut emu = emu64();
 let code = [0x48, 0xb8]; let mut full_code = code.to_vec();
 full_code.extend_from_slice(&ALIGNED_ADDR.to_le_bytes());
 full_code.extend_from_slice(&[0x48, 0xbb]);
 full_code.extend_from_slice(&ALIGNED_ADDR2.to_le_bytes());
 full_code.extend_from_slice(&[0x66, 0x0f, 0x28, 0x00, 0x66, 0x0f, 0x28, 0x0b, 0x66, 0x0f, 0x54, 0xc1, 0xf4]);
 emu.load_code_bytes(&full_code);
 emu.maps.write_bytes_slice(ALIGNED_ADDR, &[0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F]);
 emu.maps.write_bytes_slice(ALIGNED_ADDR2, &[0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0]);
    emu.run(None).unwrap();
}
#[test] fn test_andps_byte_pattern_0x33() {
    let mut emu = emu64();
 let code = [0x48, 0xb8]; let mut full_code = code.to_vec();
 full_code.extend_from_slice(&ALIGNED_ADDR.to_le_bytes());
 full_code.extend_from_slice(&[0x48, 0xbb]);
 full_code.extend_from_slice(&ALIGNED_ADDR2.to_le_bytes());
 full_code.extend_from_slice(&[0x0f, 0x28, 0x00, 0x0f, 0x28, 0x0b, 0x0f, 0x54, 0xc1, 0xf4]);
 emu.load_code_bytes(&full_code);
 emu.maps.write_bytes_slice(ALIGNED_ADDR, &[0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33]);
 emu.maps.write_bytes_slice(ALIGNED_ADDR2, &[0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC]);
    emu.run(None).unwrap();
}
#[test] fn test_andpd_byte_pattern_0x33() {
    let mut emu = emu64();
 let code = [0x48, 0xb8]; let mut full_code = code.to_vec();
 full_code.extend_from_slice(&ALIGNED_ADDR.to_le_bytes());
 full_code.extend_from_slice(&[0x48, 0xbb]);
 full_code.extend_from_slice(&ALIGNED_ADDR2.to_le_bytes());
 full_code.extend_from_slice(&[0x66, 0x0f, 0x28, 0x00, 0x66, 0x0f, 0x28, 0x0b, 0x66, 0x0f, 0x54, 0xc1, 0xf4]);
 emu.load_code_bytes(&full_code);
 emu.maps.write_bytes_slice(ALIGNED_ADDR, &[0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33]);
 emu.maps.write_bytes_slice(ALIGNED_ADDR2, &[0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC]);
    emu.run(None).unwrap();
}
#[test] fn test_andps_self() {
    let mut emu = emu64();
 let code = [0x48, 0xb8]; let mut full_code = code.to_vec();
 full_code.extend_from_slice(&ALIGNED_ADDR.to_le_bytes());
 full_code.extend_from_slice(&[0x0f, 0x28, 0x00, 0x0f, 0x54, 0xc0, 0xf4]);
 emu.load_code_bytes(&full_code);
 emu.maps.write_bytes_slice(ALIGNED_ADDR, &make_4floats(1.0, 2.0, 3.0, 4.0));
    emu.run(None).unwrap();
}
#[test] fn test_andpd_self() {
    let mut emu = emu64();
 let code = [0x48, 0xb8]; let mut full_code = code.to_vec();
 full_code.extend_from_slice(&ALIGNED_ADDR.to_le_bytes());
 full_code.extend_from_slice(&[0x66, 0x0f, 0x28, 0x00, 0x66, 0x0f, 0x54, 0xc0, 0xf4]);
 emu.load_code_bytes(&full_code);
 emu.maps.write_bytes_slice(ALIGNED_ADDR, &make_2doubles(1.0, 2.0));
    emu.run(None).unwrap();
}
#[test] fn test_andps_chained() {
    let mut emu = emu64();
 let code = [0x48, 0xb8]; let mut full_code = code.to_vec();
 full_code.extend_from_slice(&ALIGNED_ADDR.to_le_bytes());
 full_code.extend_from_slice(&[0x48, 0xbb]);
 full_code.extend_from_slice(&ALIGNED_ADDR2.to_le_bytes());
 full_code.extend_from_slice(&[0x0f, 0x28, 0x00, 0x0f, 0x28, 0x0b, 0x0f, 0x54, 0xc1, 0x0f, 0x54, 0xc1, 0xf4]);
 emu.load_code_bytes(&full_code);
 emu.maps.write_bytes_slice(ALIGNED_ADDR, &[0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF]);
 emu.maps.write_bytes_slice(ALIGNED_ADDR2, &[0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F]);
    emu.run(None).unwrap();
}
#[test] fn test_andpd_chained() {
    let mut emu = emu64();
 let code = [0x48, 0xb8]; let mut full_code = code.to_vec();
 full_code.extend_from_slice(&ALIGNED_ADDR.to_le_bytes());
 full_code.extend_from_slice(&[0x48, 0xbb]);
 full_code.extend_from_slice(&ALIGNED_ADDR2.to_le_bytes());
 full_code.extend_from_slice(&[0x66, 0x0f, 0x28, 0x00, 0x66, 0x0f, 0x28, 0x0b, 0x66, 0x0f, 0x54, 0xc1, 0x66, 0x0f, 0x54, 0xc1, 0xf4]);
 emu.load_code_bytes(&full_code);
 emu.maps.write_bytes_slice(ALIGNED_ADDR, &[0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF]);
 emu.maps.write_bytes_slice(ALIGNED_ADDR2, &[0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F]);
    emu.run(None).unwrap();
}
// Additional tests to reach 40+ count
#[test] fn test_andps_pattern_1() {
    let mut emu = emu64();
 let code = [0x48, 0xb8]; let mut full_code = code.to_vec();
 full_code.extend_from_slice(&ALIGNED_ADDR.to_le_bytes());
 full_code.extend_from_slice(&[0x48, 0xbb]);
 full_code.extend_from_slice(&ALIGNED_ADDR2.to_le_bytes());
 full_code.extend_from_slice(&[0x0f, 0x28, 0x00, 0x0f, 0x28, 0x0b, 0x0f, 0x54, 0xc1, 0xf4]);
 emu.load_code_bytes(&full_code);
 emu.maps.write_bytes_slice(ALIGNED_ADDR, &[0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88, 0x99, 0xAA, 0xBB, 0xCC, 0xDD, 0xEE, 0xFF, 0x00]);
 emu.maps.write_bytes_slice(ALIGNED_ADDR2, &[0xFF, 0xEE, 0xDD, 0xCC, 0xBB, 0xAA, 0x99, 0x88, 0x77, 0x66, 0x55, 0x44, 0x33, 0x22, 0x11, 0x00]);
    emu.run(None).unwrap();
}
#[test] fn test_andpd_pattern_1() {
    let mut emu = emu64();
 let code = [0x48, 0xb8]; let mut full_code = code.to_vec();
 full_code.extend_from_slice(&ALIGNED_ADDR.to_le_bytes());
 full_code.extend_from_slice(&[0x48, 0xbb]);
 full_code.extend_from_slice(&ALIGNED_ADDR2.to_le_bytes());
 full_code.extend_from_slice(&[0x66, 0x0f, 0x28, 0x00, 0x66, 0x0f, 0x28, 0x0b, 0x66, 0x0f, 0x54, 0xc1, 0xf4]);
 emu.load_code_bytes(&full_code);
 emu.maps.write_bytes_slice(ALIGNED_ADDR, &[0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88, 0x99, 0xAA, 0xBB, 0xCC, 0xDD, 0xEE, 0xFF, 0x00]);
 emu.maps.write_bytes_slice(ALIGNED_ADDR2, &[0xFF, 0xEE, 0xDD, 0xCC, 0xBB, 0xAA, 0x99, 0x88, 0x77, 0x66, 0x55, 0x44, 0x33, 0x22, 0x11, 0x00]);
    emu.run(None).unwrap();
}
#[test] fn test_andps_pattern_2() {
    let mut emu = emu64();
 let code = [0x48, 0xb8]; let mut full_code = code.to_vec();
 full_code.extend_from_slice(&ALIGNED_ADDR.to_le_bytes());
 full_code.extend_from_slice(&[0x48, 0xbb]);
 full_code.extend_from_slice(&ALIGNED_ADDR2.to_le_bytes());
 full_code.extend_from_slice(&[0x0f, 0x28, 0x00, 0x0f, 0x28, 0x0b, 0x0f, 0x54, 0xc1, 0xf4]);
 emu.load_code_bytes(&full_code);
 emu.maps.write_bytes_slice(ALIGNED_ADDR, &[0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01]);
 emu.maps.write_bytes_slice(ALIGNED_ADDR2, &[0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01]);
    emu.run(None).unwrap();
}
#[test] fn test_andpd_pattern_2() {
    let mut emu = emu64();
 let code = [0x48, 0xb8]; let mut full_code = code.to_vec();
 full_code.extend_from_slice(&ALIGNED_ADDR.to_le_bytes());
 full_code.extend_from_slice(&[0x48, 0xbb]);
 full_code.extend_from_slice(&ALIGNED_ADDR2.to_le_bytes());
 full_code.extend_from_slice(&[0x66, 0x0f, 0x28, 0x00, 0x66, 0x0f, 0x28, 0x0b, 0x66, 0x0f, 0x54, 0xc1, 0xf4]);
 emu.load_code_bytes(&full_code);
 emu.maps.write_bytes_slice(ALIGNED_ADDR, &[0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01]);
 emu.maps.write_bytes_slice(ALIGNED_ADDR2, &[0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01]);
    emu.run(None).unwrap();
}
#[test] fn test_andps_pattern_3() {
    let mut emu = emu64();
 let code = [0x48, 0xb8]; let mut full_code = code.to_vec();
 full_code.extend_from_slice(&ALIGNED_ADDR.to_le_bytes());
 full_code.extend_from_slice(&[0x48, 0xbb]);
 full_code.extend_from_slice(&ALIGNED_ADDR2.to_le_bytes());
 full_code.extend_from_slice(&[0x0f, 0x28, 0x00, 0x0f, 0x28, 0x0b, 0x0f, 0x54, 0xc1, 0xf4]);
 emu.load_code_bytes(&full_code);
 emu.maps.write_bytes_slice(ALIGNED_ADDR, &[0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80]);
 emu.maps.write_bytes_slice(ALIGNED_ADDR2, &[0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80]);
    emu.run(None).unwrap();
}
#[test] fn test_andpd_pattern_3() {
    let mut emu = emu64();
 let code = [0x48, 0xb8]; let mut full_code = code.to_vec();
 full_code.extend_from_slice(&ALIGNED_ADDR.to_le_bytes());
 full_code.extend_from_slice(&[0x48, 0xbb]);
 full_code.extend_from_slice(&ALIGNED_ADDR2.to_le_bytes());
 full_code.extend_from_slice(&[0x66, 0x0f, 0x28, 0x00, 0x66, 0x0f, 0x28, 0x0b, 0x66, 0x0f, 0x54, 0xc1, 0xf4]);
 emu.load_code_bytes(&full_code);
 emu.maps.write_bytes_slice(ALIGNED_ADDR, &[0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80]);
 emu.maps.write_bytes_slice(ALIGNED_ADDR2, &[0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80]);
    emu.run(None).unwrap();
}
#[test] fn test_andps_pattern_4() {
    let mut emu = emu64();
 let code = [0x48, 0xb8]; let mut full_code = code.to_vec();
 full_code.extend_from_slice(&ALIGNED_ADDR.to_le_bytes());
 full_code.extend_from_slice(&[0x48, 0xbb]);
 full_code.extend_from_slice(&ALIGNED_ADDR2.to_le_bytes());
 full_code.extend_from_slice(&[0x0f, 0x28, 0x00, 0x0f, 0x28, 0x0b, 0x0f, 0x54, 0xc1, 0xf4]);
 emu.load_code_bytes(&full_code);
 emu.maps.write_bytes_slice(ALIGNED_ADDR, &[0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F]);
 emu.maps.write_bytes_slice(ALIGNED_ADDR2, &[0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01]);
    emu.run(None).unwrap();
}
#[test] fn test_andpd_pattern_4() {
    let mut emu = emu64();
 let code = [0x48, 0xb8]; let mut full_code = code.to_vec();
 full_code.extend_from_slice(&ALIGNED_ADDR.to_le_bytes());
 full_code.extend_from_slice(&[0x48, 0xbb]);
 full_code.extend_from_slice(&ALIGNED_ADDR2.to_le_bytes());
 full_code.extend_from_slice(&[0x66, 0x0f, 0x28, 0x00, 0x66, 0x0f, 0x28, 0x0b, 0x66, 0x0f, 0x54, 0xc1, 0xf4]);
 emu.load_code_bytes(&full_code);
 emu.maps.write_bytes_slice(ALIGNED_ADDR, &[0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F]);
 emu.maps.write_bytes_slice(ALIGNED_ADDR2, &[0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01]);
    emu.run(None).unwrap();
}
#[test] fn test_andps_xmm4_xmm5() {
    let mut emu = emu64();
 let code = [0x48, 0xb8]; let mut full_code = code.to_vec();
 full_code.extend_from_slice(&ALIGNED_ADDR.to_le_bytes());
 full_code.extend_from_slice(&[0x48, 0xbb]);
 full_code.extend_from_slice(&ALIGNED_ADDR2.to_le_bytes());
 full_code.extend_from_slice(&[0x0f, 0x28, 0x20, 0x0f, 0x28, 0x2b, 0x0f, 0x54, 0xe5, 0xf4]);
 emu.load_code_bytes(&full_code);
 emu.maps.write_bytes_slice(ALIGNED_ADDR, &[0xC3, 0xC3, 0xC3, 0xC3, 0xC3, 0xC3, 0xC3, 0xC3, 0xC3, 0xC3, 0xC3, 0xC3, 0xC3, 0xC3, 0xC3, 0xC3]);
 emu.maps.write_bytes_slice(ALIGNED_ADDR2, &[0x3C, 0x3C, 0x3C, 0x3C, 0x3C, 0x3C, 0x3C, 0x3C, 0x3C, 0x3C, 0x3C, 0x3C, 0x3C, 0x3C, 0x3C, 0x3C]);
    emu.run(None).unwrap();
}
#[test] fn test_andpd_xmm4_xmm5() {
    let mut emu = emu64();
 let code = [0x48, 0xb8]; let mut full_code = code.to_vec();
 full_code.extend_from_slice(&ALIGNED_ADDR.to_le_bytes());
 full_code.extend_from_slice(&[0x48, 0xbb]);
 full_code.extend_from_slice(&ALIGNED_ADDR2.to_le_bytes());
 full_code.extend_from_slice(&[0x66, 0x0f, 0x28, 0x20, 0x66, 0x0f, 0x28, 0x2b, 0x66, 0x0f, 0x54, 0xe5, 0xf4]);
 emu.load_code_bytes(&full_code);
 emu.maps.write_bytes_slice(ALIGNED_ADDR, &[0xC3, 0xC3, 0xC3, 0xC3, 0xC3, 0xC3, 0xC3, 0xC3, 0xC3, 0xC3, 0xC3, 0xC3, 0xC3, 0xC3, 0xC3, 0xC3]);
 emu.maps.write_bytes_slice(ALIGNED_ADDR2, &[0x3C, 0x3C, 0x3C, 0x3C, 0x3C, 0x3C, 0x3C, 0x3C, 0x3C, 0x3C, 0x3C, 0x3C, 0x3C, 0x3C, 0x3C, 0x3C]);
    emu.run(None).unwrap();
}
